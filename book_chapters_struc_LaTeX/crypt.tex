%%%%(c)
%%%%(c)  This file is a portion of the source for the textbook
%%%%(c)
%%%%(c)    Abstract Algebra: Theory and Applications
%%%%(c)    Copyright 1997 by Thomas W. Judson
%%%%(c)
%%%%(c)  See the file COPYING.txt for copying conditions
%%%%(c)
%%%%(c)
\chapter{Introduction to Cryptography}\label{crypt}

Cryptography is the study of sending and receiving secret messages.\footnote{This chapter has only minor changes from Tom Judson's original version.}
The aim of cryptography is to send messages across a channel so only
the intended recipient of the message can read it. In addition, when a
message is received, the recipient usually requires some assurance that
the message is authentic; that is, that it has not been sent by
someone who is trying to deceive the recipient. Modern cryptography is
heavily dependent on abstract algebra and number theory. 
 
 
The message to be sent is called the \bfii{
plaintext\/}\index{Plaintext} message. The disguised message is called
the \bfii{ ciphertext}\index{Ciphertext}. The plaintext and the
ciphertext are both written in an \bfii{ alphabet}, consisting of \bfii{
letters\/} or \bfii{ characters}. Characters can include not only the
familiar alphabetic characters A, $\ldots$, Z and a, $\ldots$, z but
also digits, punctuation marks, and blanks. A \bfii{
cryptosystem},\index{Cryptosystem!definition of} or \bfii{
cipher},\index{Cipher}  has two parts: \bfii{ encryption}, the process
of transforming a plaintext message to a ciphertext message, and \bfii{
decryption}, the reverse transformation of changing a ciphertext
message into a plaintext message.
 
 
There are many different families of cryptosystems, each distinguished
by a particular encryption algorithm. Cryptosystems in a specified
cryptographic family are distinguished from one another by a parameter
to the encryption function called a \bfii{ key}\index{Key!definition
of}. A classical cryptosystem has a single key, which must be kept
secret,  known only to the sender and the receiver of the message. If
person $A$ wishes to send secret messages to two different people $B$
and $C$, and does not wish to have $B$ understand $C$'s messages or
vice versa, $A$ must use two separate keys, so one cryptosystem is
used for exchanging messages with $B$, and another is used for
exchanging messages with $C$.
 
 
Systems that use two separate keys, one for encoding and another for
decoding, are called \bfii{ public key
cryptosystems}\index{Key!public}\index{Cryptosystem!public key}. Since
knowledge of the encoding key does not allow anyone to guess at the
decoding key, the encoding key can be made public. A public key
cryptosystem allows $A$ and $B$ to send messages to $C$ using the same
encoding key.  Anyone is capable of encoding a message to be sent to
$C$, but only $C$ knows how to decode such a message.
 
 
 
\section{Private Key Cryptography}
 
 
In \bfii{ single\/}\index{Key!single}\index{Cryptosystem!single key} or
\bfii{ private key
cryptosystems\/}\index{Key!private}\index{Cryptosystem!private key}
the same key is used for both encrypting and decrypting messages. To
encrypt a  plaintext message, we apply to the message some function
which is kept secret, say $f$. This function will yield an encrypted
message.  Given the encrypted form of the message, we can recover the
original message by applying the inverse transformation $f^{-1}$. The
transformation $f$ must be relatively easy to compute, as must
$f^{-1}$; however, $f$ must be extremely difficult to guess at if only
examples of coded messages are available.
 
 
\medskip
 
 
\begin{example}
One of the first and most famous private key cryptosystems was the
shift code used by Julius Caesar\index{Caesar, Julius}.  We first digitize the alphabet by
letting $\mbox{A}  = 00, \mbox{B}  = 01, \ldots, \mbox{Z} = 25$.
The encoding function will be 
$$
f(p) =\bmod( p + 3,  26);
$$
that is, $A \mapsto D, B \mapsto E, \ldots, Z \mapsto C$. Notice that we could also write this as:
$$
f(p) =p \oplus 3,
$$
with the understanding that $\oplus$ refers to addition in $\mathbb{Z}_{26}$.
The decoding
function is then 
$$
f^{-1}(p) = \bmod(p - 3,26) \qquad \textrm{ or } \qquad f^{-1}(p) = \bmod(p +23,26),
$$
which could also be written as:
$$
f^{-1}(p) = p \ominus 3 \qquad \textrm{ (or }\qquad f^{-1}(p) = p \oplus 23.
$$

Suppose we receive the encoded message DOJHEUD. To decode this
message, we first digitize it:  
$$
3, 14, 9, 7, 4, 20, 3.
$$
Next we apply the inverse transformation to get
$$
0, 11, 6, 4, 1, 17, 0,
$$
or ALGEBRA. Notice here that there is nothing special about either of
the numbers 3 or 26. We could have used a larger alphabet or a
different shift.
\mbox{\hspace{1in}}
\end{example}
 
 
\medskip
 
 
\bfii{ Cryptanalysis\/}\index{Cryptanalysis} is concerned with
deciphering a received or intercepted message. Methods from
probability and statistics are great aids in deciphering an
intercepted message; for example, the frequency analysis of the
characters appearing in the intercepted message often makes its
decryption possible.  
 
 
\medskip
 
 
\begin{example}
Suppose we receive a message that we know was encrypted by using a
shift transformation on single letters of the 26-letter alphabet. To
find out exactly what the shift transformation was, we must compute
$b$ in the equation $f(p) = p + b \bmod 26$. We can do this using
frequency analysis\index{Frequency analysis}.  The letter $\mbox{E} = 04$ is the most commonly
occurring letter in the English language. Suppose that $\mbox{S} = 18$
is the most commonly occurring letter in the ciphertext.  Then we have
good reason to suspect that  $18 = 4 \oplus b $, or $b= 14$.
Therefore, the most likely encrypting function is
$$
f(p) = p \oplus 14.
$$
The corresponding decrypting function is
$$
f^{-1}(p) = p \oplus 12.
$$
It is now easy to determine whether or not our guess is correct.
\end{example}
 
 
\medskip
 
 
Simple shift codes are examples of \bfii{ monoalphabetic
cryptosystems}\index{Cryptosystem!monoalphabetic}. In these ciphers a
character in the enciphered message represents exactly one character
in the original message. Such cryptosystems are not very sophisticated
and are quite easy to break. In fact, in a simple shift as described
in Example~1, there are only 26 possible keys. It would be quite easy
to try them all rather than to use frequency analysis. 
 
 
Let us investigate a slightly more sophisticated cryptosystem. Suppose
that the encoding function is given by  
$$
f(p) = \bmod(ap + b,  26),
$$
which can also be written as
$$
f(p) = (a \odot p) \oplus b.
$$
We first need to find out when a decoding function $f^{-1}$ exists.
Such a decoding function exists when we can solve the equation
$$
c \equiv ap + b \pmod{26}\qquad \textrm{or}\qquad ap \equiv c - b \pmod{26}
$$
for $p$. By Proposition~2.1, this is possible exactly when $a$ has an
inverse or, equivalently, when $\gcd( a, 26) =1$. In this case 
$$
f^{-1}(p) = (a^{-1} \odot p)  \ominus (a^{-1}\odot b).
$$
Such a cryptosystem is called an \bfii{ affine
cryptosystem}\index{Cryptosystem!affine}. 
  
\medskip
 
\begin{exercise}\label{exercise::}
 Show that the expression for $f^{-1}$ is correct.  (That is, show that $f \compose f^{-1}= f^{-1}\compose  f =  \Id$.)
\end{exercise}

\begin{example}
Let us consider the affine cryptosystem $f(p) = \bmod(ap + b, 26)$. For
this cryptosystem to work we must choose an $a \in {\Bbb Z}_{26}$
that is invertible. This is only possible if $\gcd(a, 26) = 1$.
Recognizing this fact, we will let $a = 5$ since $\gcd(5, 26) = 1$. It
is easy to see that $a^{-1} = 21$. Therefore, we can take our
encryption function to be $f(p) = \bmod(5p + 3,26) $. Thus, ALGEBRA is
encoded as $3, 6, 7, 23, 8, 10, 3$, or DGHXIKD. The decryption
function will~be   
$$
f^{-1}(p) = \bmod(21 p - 21 \cdot 3, 26)  = \bmod(21 p + 15, 26).
$$
\end{example}
 
 
\medskip
 
 
A cryptosystem would be more secure if a ciphertext letter could
represent more than one plaintext letter.  To give an example of this
type of cryptosystem, called a \bfii{ polyalphabetic
cryptosystem},\index{Cryptosystem!polyalphabetic} we will generalize
affine codes by using matrices. The idea works roughly the same as
before; however, instead of encrypting one letter at a time we will
encrypt pairs of letters.  We can store a pair of letters $p_1$ and
$p_2$ in a vector  
$$
{\bold p} = 
\left(
\begin{array}{c}
p_1 \\ p_2
\end{array}
\right).
$$
Let $A$ be a $2 \times 2$ invertible matrix
with entries in ${\Bbb Z}_{26}$. We can define an encoding function by
$$
f({\bold p}) = A \odot {\bold p} \oplus {\bold b} ,
$$
where ${\bold b}$ is a fixed column vector and matrix operations are
performed in ${\Bbb Z}_{26}$. The decoding function must be
$$
f^{-1}({\bold p}) = (A^{-1} \odot {\bold p}) \ominus (A^{-1} \odot {\bold b}).
$$
 
 
\medskip
 
 
\begin{example}
Suppose that we wish to encode the word HELP. The corresponding
digit string is $7, 4, 11, 15$. If
$$
A =
\left(
\begin{array}{cc}
3 & 5 \\
1 & 2
\end{array}
\right),
$$
then
$$
A^{-1} 
=
\left(
\begin{array}{cc}
2 & 21 \\
25 & 3
\end{array}
\right).
$$
(You may check that $\bmod(AA^{-1},26) = \bmod(A^{-1}A,26) = $ the $2 \times 2$ identity matrix.)
If ${\bold b} = ( 2, 2)^{\rm t}$, then our message is encrypted as
RRCR, where HE encrypts as RR and LP encrypts as CR.
\end{example} 
 
 
\medskip
 
 
Frequency analysis can still be performed on a polyalphabetic
cryptosystem, because we have a good understanding of how pairs of
letters appear in the English language. The pair {\em th} appears
quite often; the pair {\em qz} never appears.  To avoid decryption by
a third party, we must use a larger matrix than the one we used in
Example~4. 
  
 
 
\section{Public Key Cryptography}
 
 
 
If traditional cryptosystems are used, anyone who knows enough to
encode a message will also know enough to decode an intercepted
message. In 1976, W.~Diffie\index{Diffie, W.} and
M.~Hellman\index{Hellman, M.} proposed public key cryptography, which
is based on the observation that the encryption and decryption
procedures need not have the same key. This removes the requirement
that the encoding key be kept secret. The encoding function $f$ must
be relatively easy to compute, but $f^{-1}$ must be extremely
difficult to compute without some additional information, so that
someone who knows only the encrypting key cannot find the decrypting
key without prohibitive computation. It is interesting to note that to
date, no system has been proposed that has been proven to be
``one-way;'' that is, for any existing public key cryptosystem, it has
never been shown to be computationally prohibitive to decode messages
with only knowledge of the encoding key. 
 
 
 
\subsection*{The RSA Cryptosystem}
 
The RSA cryptosystem introduced by R.~Rivest\index{Rivest, R.},
A.~Shamir\index{Shamir, A.}, and L.~Adleman\index{Adleman, L.} in
1978, is based on the difficulty of factoring large numbers. Though it
is not a difficult task to find two large random primes and multiply
them together, factoring a 150-digit number that is the product of two
large primes would take 100 million computers operating at 10 million
instructions per second about 50 million years under the fastest
algorithms currently known.
 
Let us look at how RSA works in a practical context.  
Suppose that Jennifer is running an online boutique, and wants to receive
 credit card information from customers over the internet. Unfortunately it is not difficult to snoop the internet, 
and it certainly wouldn't be good for Jennifer's customers if their credit card numbers were stolen. 
So she needs a suitable code for the credit card information in order to protect her customer's privacy.
The code may be constructed as follows:
\begin{enumerate}[(a)]
\item 
Choose  two random 150-digit prime
numbers $p$ and $q$. 
\item
Compute the product $n= pq$ as well as $ m = (p - 1)(q-1)$. 
(It can be shown that $m$ is actually the number of positive integers in $\mathbb{Z}_n$ that are relatively prime to $n$.)    
\item
By trial and error, find a large random integer $E$ that is relatively prime to $m$  (that is, $\gcd(E, m) = 1$). Usually
relatively prime numbers are not uncommon, and the test for relative primality is rapid, so $E$ is not too difficult to find.  
\item
Using the Euclidean algorithm, find $D$ such that \mbox{$DE \equiv 1 \pmod{m}$}. 
\end{enumerate}
 Now, let's say that Jennifer has a  customer whos credit card number is $x$.  Before requesting the credit card information, Jennifer's computer  sends the numbers  $E$ and $n$ to the customer's computer, which then calculates $y = x^E \mod n$ and sends $y$ to
Jennifer's computer, Jennifer recovers $x$ by computing  $y^D \bmod
n$, which (as we shall show in a minute) turns out to be $x$, as long as $x$ is less than $n$. 

Notice some amazing things here. First, $E$ and $n$ are sent out \emph{openly} over the internet. Jennifer doesn't care if  snoopers find out this information. In fact, she sends the \emph{same} $E$ and $n$ to each customer! But this does not compromise her customers' security, because only Jennifer knows $m$, and it takes both $E$ and $m$ to find $D$. As long as no one can figure out $m$, the credit card numbers are safe!

 
\vspace{2 ex}
 
 
\begin{example}
Before exploring the theory behind the RSA cryptosystem or attempting
to use large integers, we will use some small integers just to see
that the system does indeed work. Suppose that we wish to send some
message, which when digitized is 395. Let $p = 23$ and $q = 29$.  Then 
$$ n = pq = 667 \qquad \textrm{and} \qquad
m = (p - 1)(q - 1) = 616.
$$
We can let $E = 487$, since $\gcd(616, 487) = 1$. The encoded message
is computed to be  
$$
\bmod(395^{487},  667) = 570.
$$
(This may seem like a very long computation, but there are fast ways of doing this: see Exercise \ref{ex:powers} at the end of this chapter.)
Using the Euclidean
algorithm, we determine that $191 E = 1 + 151 m$; therefore, the
decrypting key is $(n, D) = ( 667, 191)$. We can recover the original 
message by calculating  
$$
 \bmod(570^{191}, 667) = 395.
$$
\end{example}
 
 
\vspace{ 2 ex}
 
 
This really seems like magic. How in the world does it work? 
First of all, we know that $DE
\equiv 1 \bmod{ m}$; so there exists a $k$ such that 
$$
DE = km + 1.
$$
This means that
$$
y^D = (x^E)^D = x^{DE} = x^{km+1} = (x^m)^k x.
$$
At this point we need \emph{Euler's theorem} from Chapter~\ref{cosets}, which states the following. Suppose $m$ is the number of positive integers less than $n$ that are relatively prime to $n$. Then it is true that:
$$
x^m \equiv 1 \pmod n.
$$
for \emph{any} $x$ that is relatively prime to $n$. 

We can use this to simplify our previous expression for $y^D$:
$$
y^D =  (x^m)^k x \equiv (1)^k x  \equiv x \bmod n,
$$
 and presto! We have our result.
 
We can now ask how one would go about breaking the RSA cryptosystem.
To find $D$ given $n$ and $E$, we simply need to factor $n$ and solve
for $D$ by using the Euclidean algorithm. If we had known that $667 =
23 \cdot 29$ in Example~5, we could have recovered $D$.    
 
 
 
\subsection*{Message Verification}
 
 
There is a problem of message verification in public key
cryptosystems. Since the encoding key is public knowledge, anyone has
the ability to send an encoded message.  If Alice receives a message
from Bob, she would like to be able to verify that it was Bob who
actually sent the message. Suppose that Bob's encrypting key is $(n',
E')$ and his decrypting key is $(n', D')$.  Also, suppose that Alice's
encrypting key is $(n, E)$ and her decrypting key is $(n, D)$.  Since
encryption keys are public information, they can exchange coded
messages at their convenience.  Bob wishes to assure Alice that the
message he is sending is authentic. Before Bob sends the message $x$
to Alice, he decrypts  $x$ with his own key:
$$
x' =  \bmod(x ^{D'}, n').
$$
Anyone can change $x'$ back to $x$ just by encryption, but only Bob
has the ability to form $x'$. Now Bob encrypts $x'$ with Alice's
encryption key to form 
$$
y' = \bmod({x'}^E,   n),
$$
a message that only Alice can decode.  Alice decodes the message and
then encodes the result with Bob's key to read the original message, a
message that could have only been sent by Bob.
 
 
 
\histhead
 
 
\noindent{\small \histf
Encrypting secret messages goes as far back as ancient Greece and
Rome. As we know, Julius Caesar used a simple shift code to send and
receive messages. However, the formal study of  encoding and decoding
messages probably began with the Arabs in the 1400s. In the fifteenth
and sixteenth centuries mathematicians such as Alberti and Viete
discovered 
that monoalphabetic cryptosystems offered no real security. In the
1800s, F. W. Kasiski established methods for breaking ciphers in
which a ciphertext letter can represent more than one plaintext
letter, if the same key was used several times. This discovery led to
the use of cryptosystems with keys that were used only a single time.
Cryptography was placed on firm mathematical foundations by such people
as W. Friedman and L. Hill in the early part of the twentieth century.
 
 
During World War II mathematicians were very active in cryptography.
Efforts to penetrate the cryptosystems of the Axis nations were 
organized in England and in the United States by such notable
mathematicians as Alan Turing and A. A. Albert. The period after
World War I saw the development of special-purpose machines for
encrypting and decrypting messages. The Allies gained a 
tremendous advantage in World War II by breaking the ciphers produced by 
the German Enigma machine and the Japanese Purple ciphers.
 
 
By the 1970s, interest in commercial cryptography had begun to take
hold. There was a growing need to protect banking transactions,
computer data, and electronic mail. In the early 1970s, IBM developed
and implemented LUZIFER, the forerunner  of the National Bureau of
Standards' Data Encryption Standard (DES). 
 
 
The concept of a public key cryptosystem, due to Diffie and Hellman,
is very recent (1976). It was further developed by Rivest,  
Shamir, and Adleman with the RSA cryptosystem (1978). It is not known
how secure any of these systems are. The trapdoor knapsack
cryptosystem, developed by Merkle and Hellman, has been broken. It is
still an open question whether or not the RSA system can be broken. At
the time of the writing of this book, the largest number factored is
135 digits long, and at the present moment a code is considered secure if
the key is about 400 digits long and is the product of two 200-digit primes.
There has been a great deal of controversy about research in
cryptography in recent times: the National Security Agency would like to
keep information about cryptography secret, whereas the academic community
has fought for the right to publish basic research.   
 
 
Modern cryptography has come a long way since 1929, when Henry Stimson, 
Secretary of State under Herbert Hoover, dismissed the Black Chamber
(the State Department's cryptography division) in 1929 on the ethical 
grounds that ``gentlemen do not read each other's mail.''
\histbox
}
 
 
 
\markright{EXERCISES}
\section*{Additional Exercises}
\exrule
 
 
{\small 
\begin{enumerate}
 
\bf\item\rm
Encode IXLOVEXMATH using the cryptosystem in Example~1.
 
\bf\item\rm
Decode ZLOOA WKLVA EHARQ WKHA ILQDO, which was encoded using the
cryptosystem in Example~1. 
 
 
\bf\item\rm
Assuming that monoalphabetic code was used to encode the following
secret message, what was the original message?
\begin{center}
NBQFRSMXZF YAWJUFHWFF ESKGQCFWDQ AFNBQFTILO FCWP
\end{center}
 
 
 
\bf\item\rm
What is the total number of possible monoalphabetic cryptosystems? How 
secure are such cryptosystems?
 
 
\bf\item\rm
Prove that a $2 \times 2$ matrix $A$ with entries in ${\Bbb Z}_{26}$
is invertible if and only if $\gcd( \det(A), 26 ) = 1$.
 
 
 
\bf\item\rm
Given the matrix 
$$
A =
\left(
\begin{array}{cc}
3 & 4 \\
2 & 3
\end{array}
\right),
$$
use the encryption function $f({\bold p}) = A {\bold p} + {\bold b}$
to encode the message CRYPTOLOGY, where ${\bold b} = ( 2, 5)^{\rm
t}$.  What is the decoding function?  
 
 
\bf\item\rm
Show that if $p$ and $q$ are primes, then the number of positive integers less than $pq$ which are relatively prime to $pq$ is $(p-1)(q-1)$.  
\emph{Hint:} It is possible to list all of the numbers between $1$ and $pq$ which are \emph{not} relatively prime to $pq$.



\bf\item \label{ex:powers} \rm
This problem demonstrates a fast method for computing very large powers of numbers in modular arithmetic using a spreadsheet.  You will need this method in order to do the subsequent problems. We will demonstrate the method by computing $\bmod(23^{487} ,617)$.
\begin{enumerate}
\item
Use a spreadsheet to compute the following sequence of numbers:
\[ 23, \bmod(23^2 ,617),\bmod(23^4 ,617),\ldots,\bmod(23^{256} ,617) \]
Note that each power of 23 in this series is the  \emph{square} of the previous power.  So to compute any number in this series, square the previous number and reduce mod 617.  You may use the MOD spreadsheet function.  It is easiest to put all the numbers in a single column. (This way, you can use the spreadsheet's ``Fill down'' feature.)
\item  Write 487 as a sum of powers of 2.  (This is the same thing as finding the \emph{binary expansion} of 487.)
\item Using the results of (b), identify a set of entries from the table you found in part (a), such that the product of these entries is equivalent to $23^{487}  \pmod{617}$.  (\emph{Remember your exponent rules!})
\item 
Use your result from (c) to compute $\bmod(23^{487} ,617)$.
\end{enumerate}
 
\bf\item \label{ex:encode} \rm
Encrypt each of the following RSA messages $x$ so that $x$ is divided
into blocks of integers of length 2;  that is, if $x = 142528$, encode 
14, 25, and 28 separately.
 
 
\vspace{3pt}        %two column exercise list
 
\hspace{-7pt}
\begin{minipage}[t]{4.6in}
\noindent
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (a)}]
$n = 3551, E = 629, x = 31$
 
 \item[{\bf (c)}]
$n = 120979, E = 13251,\\ x = 142371$
 
\end{itemize}
\end{minipage} \hfill
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (b)}]
$n = 2257, E = 47, x = 23$
 
 \item[{\bf (d)}]
$n = 45629, E = 781,\\ x = 231561$
 
\end{itemize}
\end{minipage}
\end{minipage}
 
\vspace{2pt}        %end two column exercise list
 
 
 
\bf\item\rm
Compute the decoding key $D$ for each of the encoding keys in
Exercise~\ref{ex:encode}. 
 
 
\bf\item\rm
Decrypt each of the following RSA messages $y$.
 
 
\vspace{3pt}        %two column exercise list
 
\hspace{-7pt}
\begin{minipage}[t]{4.6in}
\noindent
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (a)}]
$n = 3551, D = 1997, y = 2791$
 
 \item[{\bf (c)}]
$n = 120979, D = 27331,\\ y = 112135$
 
\end{itemize}
\end{minipage} \hfill
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (b)}]
$n = 5893, D = 81, y = 34$
 
 \item[{\bf (d)}]
$n = 79403, D = 671,\\ y = 129381$
 
\end{itemize}
\end{minipage}
\end{minipage}
 
\vspace{2pt}        %end two column exercise list
 
 
 
\bf\item\rm
For each of the following encryption keys $(n, E)$ in the RSA
cryptosystem, compute $D$.
 
\vspace{3pt}        %two column exercise list
 
\hspace{-7pt}
\begin{minipage}[t]{4.6in}
\noindent
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (a)}]
$(n, E) = (451, 231)$
 
 \item[{\bf (c)}]
$(n, E) = (37986733, 12371)$
 
\end{itemize}
\end{minipage} \hfill
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (b)}]
$(n, E) = (3053, 1921)$
 
 \item[{\bf (d)}]
$(n, E) =\\ (16394854313, 34578451)$
 
\end{itemize}
\end{minipage}
\end{minipage}
 
\vspace{2pt}        %end two column exercise list
 
 
 
 
\bf\item\rm
Encrypted messages are often divided into blocks of $n$ letters. A
message such as THE WORLD WONDERS WHY might be encrypted as 
JIW OCFRJ LPOEVYQ IOC but sent as JIW OCF RJL POE VYQ
IOC.  What are the advantages of using blocks of $n$ letters? 
 
 
%\bf\item\rm
%Find integers $n$, $E$, and $X$ such that
%$$
%X^E \equiv X \pmod{n}.
%$$
%Is this a potential problem in the RSA cryptosystem?
 
 
\bf\item\rm
Every person in the class should construct an RSA cryptosystem using primes
that are 10 to 15 digits long.  Hand in $(n, E)$ and an encoded 
message. Keep $D$ secret. See if you can break one another's codes.
 
 
\end{enumerate}
}
 
 
\subsection*{Additional Exercises: Primality and Factoring}
 
{\small 
 
 
In the RSA cryptosystem it is important to be able to find
large prime numbers easily.  Also, this cryptosystem is not secure if we
can factor a composite number that is the product of two large primes.
The solutions to both of these problems are quite easy.  To
find out if a number $n$ is prime or to factor $n$, we can use trial
division. We simply divide $n$ by $d = 2, 3, \ldots, \sqrt{n}$.
Either a factorization will be obtained, or $n$ is prime if no $d$
divides $n$.  The problem is that such a computation is prohibitively
time-consuming if $n$ is very large. 
\begin{enumerate}
 
 
\bf\item\rm
A better algorithm for factoring odd positive integers is \bfii{
Fermat's factorization algorithm}\index{Fermat's factorization
algorithm}. 
\begin{enumerate}
 
\bf\item\rm
Let $n= ab$ be an odd composite number. Prove that $n$ can be written
as the difference of two perfect squares:
$$
n = x^2 - y^2 = (x-y)(x+y).
$$
Consequently, a positive odd integer can be factored exactly when we
can find integers $x$ and $y$ such that $n = x^2 - y^2$.
 
\bf\item\rm
Write a program to implement the following factorization algorithm
based on the observation in part (a).
 
\vspace{1ex}
 
{\tt
\begin{tabbing}
xxxx\=xxxx\=xxxx\=xxxx \kill
\> $x \leftarrow \lceil \sqrt{n}\, \rceil$ \\
\> $y \leftarrow 1$ \\
\mbox{\hspace*{1in}} \\
1: \> while $x^2 - y^2 > n$ do \\
\> \> $y \leftarrow y + 1$ \\
\mbox{\hspace*{1in}} \\
\> if $x^2 - y^2 < n$ then \\
\> \>  $x \leftarrow x + 1$ \\
\> \>  $y \leftarrow 1$ \\
\> \>  goto 1 \\
\> else if $x^2 - y^2 = 0$ then \\
\>  \> $a \leftarrow x-y$ \\
\>  \> $b \leftarrow x+y$ \\
\>  \> write $n = a * b$ 
\end{tabbing}
 
}
 
\vspace{1ex}
 
The expression  $\lceil \sqrt{n}\, \rceil$ means the smallest integer
greater than or equal to the square root of $n$. Write another program
to do factorization using trial division and compare the speed of the
two algorithms. Which algorithm is faster and why?
 
 
 
 
\end{enumerate}
 
 
\bf\item\rm
{\bf Primality Testing.}
In section \ref{sec:Fermat}, we will prove the following fact (Called \emph{Fermat's little theorem}\index{Fermat's ittle theorem}: 
\medskip

If  $p$ is any prime number and $a$ is any nonzero integer, then $a^{p-1} \equiv 1 \pmod{p}$.  
\medskip

We can use Fermat's little theorem as a screening test for primes. For example, 15 cannot be prime since
$$
2^{15-1} \equiv 2^{14} \equiv 4 \pmod{15}.
$$
However, 17 is a potential prime since
$$
2^{17-1} \equiv 2^{16} \equiv 1 \pmod{17}.
$$
We say that an odd composite number $n$ is a \bfii{
pseudoprime\/}\index{Pseudoprime} if 
$$
2^{n-1} \equiv 1 \pmod{n}.
$$
Which of the following numbers are primes  and which are pseudoprimes?
 
 
\vspace{3pt}        %two column exercise list
 
\hspace{-7pt}
\begin{minipage}[t]{4.6in}
\noindent
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (a)}]
342
 
 \item[{\bf (c)}]
601
 
 \item[{\bf (e)}]
771
 
\end{itemize}
\end{minipage} \hfill
\begin{minipage}[t]{2.25in}
\begin{itemize}
 
 \item[{\bf (b)}]
811
 
 \item[{\bf (d)}]
561
 
 \item[{\bf (f)}]
631
 
\end{itemize}
\end{minipage}
\end{minipage}
 
\vspace{2pt}        %end two column exercise list
 
 
\bf\item\rm
Let $n$ be an odd composite number and $b$ be a positive integer such
that $\gcd(b, n) = 1$. If $b^{n-1} \equiv 1 \pmod{n}$, then $n$ is a
\bfii{ pseudoprime base} $b$. Show that 341 is a pseudoprime base 2 but
not a pseudoprime base 3.
 
 
\bf\item\rm
Write a program to determine all primes less than 2000 using
trial division. Write a second program that will determine all numbers
less than 2000 that are either primes or pseudoprimes. Compare the
speed of the two programs.  How many pseudoprimes are there below
2000? 
 
 
There exist composite numbers that are pseudoprimes for all bases to
which they are relatively prime.  These numbers are called \bfii{
Carmichael numbers}\index{Carmichael numbers}. The first Carmichael
number is $561 = 3 \cdot 11 \cdot 17$.  In 1992, Alford, Granville, and
Pomerance proved that there are an infinite number of Carmichael
numbers [4].  However, Carmichael numbers are very rare.  There are
only $2163$ Carmichael numbers less than $25 \times 10^9$. For more
sophisticated primality tests, see [1], [6], or [7].  
 
 
\end{enumerate}
}
 
 
\subsection*{References and Suggested Readings}
 
{\small
\begin{itemize}
 
\item[{\bf [1]}]
Bressoud, D. M. {\it Factorization and Primality Testing}.
Springer-Verlag, New York, 1989. 
 
\item[{\bf [2]}]
Diffie, W. and Hellman, M. E. ``New Directions in
Cryptography,'' {\it IEEE Trans. Inform. Theory} {\bf
22} (1976), 644--54.
 
\item[{\bf [3]}]
Gardner, M. ``A New Kind of Cipher that Would Take a Million
Years to Break,'' {\it Scientific American} {\bf
237} (1977), 120--24.
 
\item[{\bf [4]}]%%%%%%%%%%%%%%checked
Granville, A. ``Primality Testing and Carmichael Numbers,'' {\it
Notices of the American Mathematical Society} {\bf 39}(1992),
696--700. 
 
 
 
\item[{\bf [5]}]
Hellman, M. E. ``The Mathematics of Public Key
Cryptography,''  {\it Scientific American} {\bf 241}
(1979), 130--39.
 
\item[{\bf [6]}]%%%%%%%%%%%%%%checked
Koblitz, N. {\it A Course in Number Theory and Cryptography}.
Springer-Verlag, New York, 1987. 
 
 
\item[{\bf [7]}]
Pomerance, C., ed. {\it Cryptology and Computational Number
Theory}. Proceedings of Symposia in Applied Mathematics,
vol. 42. American Mathematical Society, Providence, RI,
1990.
 
 
\item[{\bf [8]}]
Rivest, R. L., Shamir, A., and Adleman, L., ``A Method for
Obtaining Signatures and Public-key Cryptosystems,'' {\it
Comm. ACM} {\bf 21}(1978), 120--26.
 
\end{itemize}
}